# tg-webhook-bot (Python + aiogram)

Готовый шаблон для Telegram-бота на **Python**, **aiogram** и **aiohttp**. Бот работает через вебхуки и оптимизирован для простого и безопасного развертывания на сервере с помощью Docker и GitHub Actions.

## Стек технологий

- **Бот**: Python 3.11, aiogram, aiohttp
- **Деплой**: Docker, Docker Compose, GitHub Actions
- **Веб-сервер (рекомендуется)**: Caddy для автоматического HTTPS

## Что внутри репозитория

- `bot.py`: Основной код бота.
- `Dockerfile`: Инструкции для сборки Docker-образа.
- `docker-compose.yml`: Конфигурация для локального запуска и тестирования.
- `deploy/`: Каталог со скриптами для развертывания:
  - `bootstrap-server-custom.sh`: Скрипт для первоначальной настройки сервера.
  - `Caddyfile.example`: Пример конфигурации для веб-сервера Caddy.

## Как это работает: CI/CD с GitHub Actions

Этот шаблон настроен на автоматическое развертывание при пуше в ветку `main`:

1.  **Push в `main`**: Запускается workflow в GitHub Actions.
2.  **Сборка и публикация образа**: GitHub Actions собирает Docker-образ вашего бота и публикует его в GitHub Container Registry (GHCR).
3.  **Деплой на сервер**: Workflow подключается к вашему серверу по SSH и выполняет команду `docker-compose pull && docker-compose up -d`, чтобы обновить и запустить бота с новым образом.

## Шаг 1: Настройка сервера

Для развертывания бота вам понадобится сервер (VPS/VDS) с публичным IP-адресом. Скрипт `deploy/bootstrap-server-custom.sh` поможет быстро подготовить его.

**Что делает скрипт:**
- Устанавливает Docker и Docker Compose.
- Создает специального пользователя для деплоя (например, `deploy`).
- Генерирует SSH-ключ для беспарольного доступа с GitHub Actions.
- Создает структуру каталогов для бота в `/opt/pybot/<BOT_NAME>`.
- Генерирует файлы `.env` и `docker-compose.prod.yml`.

**Запуск скрипта на сервере:**

Скрипт можно запустить одной командой прямо с GitHub, не скачивая репозиторий на сервер.

> **Примечание:** Для выполнения первоначальной настройки сервера (установка Docker, создание пользователя) требуются права `sudo`.

Выполните на сервере следующие команды, подставив свои значения:

```bash
# 1. Задайте переменные
OWNER="your-github-username"      # Ваш логин на GitHub
REPO_NAME="your-repo-name"        # Название вашего репозитория на GitHub
BOT_NAME="bot_main"               # Имя для каталога бота на сервере
BOT_PORT="8001"                   # Порт на хосте, который будет слушать бот
DEPLOY_USER="deploy"              # Имя пользователя для деплоя (опционально, по умолчанию 'deploy')

# 2. Запустите скрипт с GitHub
sudo env OWNER=$OWNER REPO_NAME=$REPO_NAME BOT_NAME=$BOT_NAME BOT_PORT=$BOT_PORT DEPLOY_USER=$DEPLOY_USER \
bash -c "$(curl -fsSL https://raw.githubusercontent.com/${OWNER}/${REPO_NAME}/main/deploy/bootstrap-server-custom.sh)"
```

После выполнения скрипт выведет **секреты, которые нужно добавить в ваш репозиторий на GitHub** (`Settings -> Secrets and variables -> Actions`):
- `SSH_HOST`: IP-адрес вашего сервера.
- `SSH_USER`: Пользователь, созданный скриптом (`deploy` по умолчанию).
- `SSH_PRIVATE_KEY`: Закрытый SSH-ключ для доступа к серверу.
- `WORK_DIR`: Рабочий каталог на сервере (например, `/opt/pybot/bot_main`).

> **Важно:** После выполнения скрипта не забудьте отредактировать файл `.env` на сервере (`/opt/pybot/<BOT_NAME>/.env`) и указать ваш настоящий `BOT_TOKEN` и `WEBHOOK_HOST`.

## Шаг 2: Настройка DNS и Caddy (HTTPS)

Чтобы Telegram мог отправлять обновления на ваш вебхук, ему нужен HTTPS. Мы рекомендуем использовать Caddy — он автоматически получает и обновляет SSL-сертификаты.

1.  **Настройте DNS**: Создайте `A`-запись для вашего домена (или поддомена), которая будет указывать на IP-адрес вашего сервера.
    - `my-first-bot.your-domain.com` -> `SERVER_IP`
2.  **Настройте Caddy**: Используйте `deploy/Caddyfile.example` как шаблон. Скопируйте его содержимое в `/etc/caddy/Caddyfile` на сервере и адаптируйте под свой домен и порт.
    ```
    my-first-bot.your-domain.com {
        reverse_proxy localhost:8001 # Укажите порт (BOT_PORT) вашего бота
    }
    ```
3.  **Перезапустите Caddy**: `sudo systemctl reload caddy`.

## Локальная разработка и тестирование

Поскольку бот работает через вебхуки, для локального тестирования ему нужен публично доступный адрес. Просто запустить `docker-compose up` недостаточно.

Рекомендуемый способ — использовать **ngrok** или аналогичный сервис для создания временного публичного URL.

1.  Скопируйте `.env.example` в `.env` (если его нет).
2.  Запустите ngrok, чтобы получить публичный URL, который будет перенаправлять трафик на ваш локальный порт:
    ```bash
    # Если ваше приложение слушает порт 8080
    ngrok http 8080
    ```
3.  Скопируйте HTTPS-адрес, который выдал ngrok (например, `https://xxxx-xxxx.ngrok-free.app`), и вставьте его в `WEBHOOK_HOST` в вашем `.env` файле.
4.  Укажите `BOT_TOKEN` и `PORT` (например, `8080`).
5.  Теперь можно запустить бота локально:
    ```bash
    docker-compose up --build
    ```
6.  Смотрите логи: `docker-compose logs -f`.

## Troubleshooting

- **Бот не запускается**: Проверьте логи контейнера (`docker-compose logs -f` локально или `docker logs <container_name>` на сервере) и убедитесь, что все переменные в `.env` файле заданы корректно.
- **Вебхук не устанавливается**: Убедитесь, что `WEBHOOK_HOST` доступен извне, порт не заблокирован, и Caddy (или другой прокси) настроен правильно.
- **Ошибки деплоя GitHub Actions**: Проверьте, что все секреты (`SSH_HOST`, `SSH_USER` и т.д.) правильно добавлены в настройки репозитория, и что образ успешно публикуется в GHCR.
