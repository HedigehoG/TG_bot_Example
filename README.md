# tg-webhook-bot (Python + aiogram)

Это готовый шаблон для Telegram-бота, который использует **Python**, **aiogram** и **aiohttp**. Он работает через вебхуки и оптимизирован для простого развертывания на сервере с помощью Docker и GitHub Actions.

### Стек
- **Бот**: Python + aiogram + aiohttp
- **Деплой**: Docker + Docker Compose + GitHub Actions
- **Веб-сервер (рекомендуется)**: Caddy для автоматического HTTPS

### Быстрая подготовка (локально)
1.  Скопируйте `.env.example` в новый файл `.env`.
2.  Укажите в нем `BOT_TOKEN`, `WEBHOOK_HOST` и `PORT`.
3.  Запустите локально для проверки через Docker:

```bash
docker-compose up --build
```

### Настройка Caddy на сервере

Для маршрутизации запросов к ботам мы будем использовать поддомены (например, `my-bot.your-domain.com`). Это более чистый и гибкий подход, чем маршрутизация по URL.

**Что нужно сделать:**
1.  **Настроить DNS:** У вашего регистратора доменов создайте `A`-запись для каждого бота, которая будет указывать на IP-адрес вашего сервера.
    - `my-first-bot.your-domain.com` -> `SERVER_IP`
    - `my-second-bot.your-domain.com` -> `SERVER_IP`

2.  **Настроить Caddy:** Caddy будет автоматически получать SSL-сертификаты для каждого поддомена и перенаправлять запросы на соответствующий порт, где работает контейнер с ботом.
    **Этот порт должен совпадать со значением `BOT_PORT`**, которое вы указываете при запуске bootstrap-скрипта.
В файле `deploy/Caddyfile.example` находится пример конфигурации. Скопируйте его на свой сервер (обычно в `/etc/caddy/Caddyfile`) и адаптируйте под свои поддомены и порты.

После внесения изменений в `Caddyfile` не забудьте перезагрузить Caddy командой: `sudo systemctl reload caddy`.

### Развертывание и CI/CD (GitHub Actions)

Этот шаблон использует CI/CD-подход для развертывания. Процесс выглядит так:
1.  Вы отправляете код в `main`-ветку вашего репозитория на GitHub.
2.  GitHub Actions автоматически собирает Docker-образ вашего бота.
3.  Собранный образ публикуется в вашем приватном GitHub Container Registry (GHCR).
4.  GitHub Actions подключается к вашему серверу по SSH и выполняет команду `docker-compose pull && docker-compose up -d`, чтобы скачать новый образ и перезапустить контейнер.

Для этого необходимо один раз настроить сервер и добавить секреты в репозиторий GitHub.

#### 1. Первоначальная настройка сервера

Вся настройка автоматизирована с помощью bootstrap-скрипта.

1.  Загрузите скрипт `deploy/bootstrap-server-custom.sh` на ваш сервер.
2.  Запустите его с правами `sudo`, указав параметры для вашего бота. Скрипт установит Docker, создаст пользователя для деплоя и подготовит рабочую директорию.

**Параметры bootstrap-скрипта:**

Скрипт `bootstrap-server-custom.sh` принимает следующие переменные окружения:

| Переменная  | Описание                                                                                             | Обязательно? | По умолчанию      |
|-------------|------------------------------------------------------------------------------------------------------|--------------|-------------------|
| `OWNER`     | Ваш логин на GitHub. Необходим для указания правильного Docker-образа из GHCR в `docker-compose`.      | **Да**       | -                 |
| `BOT_NAME`  | Уникальное имя для бота. Используется для создания рабочей директории (`/opt/pybot/BOT_NAME`).         | Нет          | `bot_main`        |
| `BOT_PORT`  | Внешний порт на сервере, который будет проброшен в контейнер. Должен быть уникальным для каждого бота. | Нет          | `8001`            |
| `BOOT_USER` | Имя системного пользователя, от которого будут выполняться операции деплоя.                           | Нет          | `deploy`          |

Хотя обязательным является только `OWNER`, для развертывания нескольких ботов рекомендуется всегда явно указывать `BOT_NAME` и `BOT_PORT`, чтобы избежать конфликтов.

> **Важно:** Замените `your-github-username` на ваш логин в GitHub. Это необходимо для CI/CD, чтобы `docker-compose` на сервере знал, откуда скачивать Docker-образ вашего бота.

Пример для бота с именем `my_first_bot`, который будет работать на порту `8001`:
```bash
# Запускать на сервере
sudo OWNER=your-github-username BOOT_USER=deploy BOT_NAME=my_first_bot BOT_PORT=8001 ./bootstrap-server-custom.sh
```
После выполнения скрипт выведет команду для добавления `git remote` на вашем локальном компьютере.

3.  После первого запуска скрипта, подключитесь к серверу и отредактируйте файл с секретами (например, `/opt/pybot/my_first_bot/.env`), указав настоящий токен бота.
4.  На локальной машине добавьте remote и отправьте код на сервер:
```bash
# Запускать локально (команду git remote... возьмите из вывода скрипта)
git remote add production ssh://deploy@your-server.com/opt/pybot/conf_git/my_first_bot_repo.git
git push production main
```

### CI/CD (GitHub Actions)

Проект содержит workflow для автоматической сборки и публикации Docker-образа в GitHub Container Registry (GHCR).

1) Убедитесь, что ваш GitHub Actions workflow (в `.github/workflows/`) собирает и публикует Docker-образ в правильный репозиторий GHCR. Имя образа должно соответствовать тому, что используется в `docker-compose.prod.yml` на сервере.
   - Bootstrap-скрипт автоматически создаст `docker-compose.prod.yml` с именем образа `ghcr.io/<owner>/tg-webhook-bot:latest`, где `<owner>` — это ваш GitHub-логин, приведенный к нижнему регистру (из переменной `OWNER`).
   - Ваш workflow должен публиковать образ именно по этому пути.

2) В репозитории GitHub добавьте secrets (Settings → Secrets → Actions):
- `SSH_HOST` — IP или домен вашего сервера
- `SSH_USER` — пользователь для SSH (например, `deploy`)
- `SSH_PRIVATE_KEY` — приватный SSH ключ для доступа к серверу
- `WORK_DIR` — рабочая директория на сервере, например `/opt/pybot/my_first_bot`

#### Как настроить SSH-ключ для деплоя

Вам не нужно создавать ключи вручную. Bootstrap-скрипт сделает это за вас.

1.  При первом запуске `bootstrap-server-custom.sh` на сервере, он автоматически сгенерирует новую SSH-пару ключей.
2.  В конце выполнения скрипт выведет в консоль **приватный ключ**.
3.  **Скопируйте этот ключ** (включая строки `-----BEGIN...` и `-----END...`) и вставьте его в секрет `SSH_PRIVATE_KEY` в настройках вашего репозитория на GitHub.

3) При пуше в `main` workflow соберет образ, опубликует его в GHCR, а затем подключится по SSH к вашему серверу и выполнит `docker-compose pull && docker-compose up -d`.

### Структура файлов на сервере

Bootstrap-скрипт создает следующую структуру в `/opt/pybot/`:

```
/opt/pybot/
├── conf_git/
│   └── my_first_bot_repo.git/  # Bare-репозиторий для деплоя
└── my_first_bot/
    ├── .env                    # Файл с секретами (BOT_TOKEN и др.)
    ├── bot.py                  # Код бота (из репозитория)
    └── docker-compose.prod.yml # Compose-файл для продакшена
```

### Примечания по производительности
- Используется базовый образ `python:3.11-slim`. Для еще более компактных сборок можно рассмотреть `python:3.11-alpine`, но это может потребовать установки дополнительных пакетов для компиляции зависимостей.
- В `docker-compose.yml` установлен лимит памяти `150m` в качестве примера для защиты от утечек памяти на слабых серверах.
